<!DOCTYPE html>
<html>
<head>
    <title>PhotonicForge WebGPU Visualizer</title>
    <style>
        body { margin: 0; background: #111; color: #eee; font-family: sans-serif; }
        canvas { display: block; margin: 20px auto; border: 1px solid #444; }
        #controls { text-align: center; padding: 10px; }
    </style>
</head>
<body>
    <div id="controls">
        <h2>PhotonicForge Live Simulation</h2>
        <div id="status">Initializing WebGPU...</div>
    </div>
    <canvas id="simCanvas" width="800" height="600"></canvas>

    <!-- Shader Code will be injected here -->
    <script id="wgsl-shader" type="x-shader/x-wgsl">
    /* INJECT_SHADER_HERE */
    </script>
    
    <!-- Simulation Data will be injected here -->
    <script id="sim-data" type="application/json">
    /* INJECT_DATA_HERE */
    </script>

    <script type="module">
        async function init() {
            const status = document.getElementById('status');
            
            if (!navigator.gpu) {
                status.textContent = "WebGPU not supported on this browser.";
                return;
            }

            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();
            
            const canvas = document.getElementById('simCanvas');
            const context = canvas.getContext('webgpu');
            const format = navigator.gpu.getPreferredCanvasFormat();
            
            context.configure({ device, format });

            // Load Data
            const dataScript = document.getElementById('sim-data').textContent;
            // In a real export, this would be populated. 
            // For template testing, we'll generate dummy data if empty.
            let simParams = { nx: 200, ny: 150, dx: 0.1, dt: 0.05 };
            let epsilonData = new Float32Array(200 * 150).fill(1.0);
            
            if (!dataScript.includes("INJECT_DATA_HERE")) {
                 const parsed = JSON.parse(dataScript);
                 simParams = parsed.params;
                 epsilonData = new Float32Array(parsed.epsilon);
            }

            // Create Buffers
            const size = simParams.nx * simParams.ny * 4; // bytes
            
            const hzBuf = device.createBuffer({ size, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
            const exBuf = device.createBuffer({ size, usage: GPUBufferUsage.STORAGE });
            const eyBuf = device.createBuffer({ size, usage: GPUBufferUsage.STORAGE });
            const epsBuf = device.createBuffer({ size: epsilonData.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST }); 
            
            device.queue.writeBuffer(epsBuf, 0, epsilonData);

            const paramsBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
            device.queue.writeBuffer(paramsBuf, 0, new Uint32Array([simParams.nx, simParams.ny]));
            device.queue.writeBuffer(paramsBuf, 8, new Float32Array([simParams.dt, simParams.dx]));

            const sourceValBuf = device.createBuffer({ size: 4, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

            // Compile Shader
            const shaderCode = document.getElementById('wgsl-shader').textContent;
            const shaderModule = device.createShaderModule({ code: shaderCode });

            // Pipeline
            const bindGroupLayout = device.createBindGroupLayout({
                entries: [
                    { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },
                    { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
                    { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
                    { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
                    { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
                    { binding: 5, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },
                ]
            });

            const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] });
            
            const updateHPipeline = device.createComputePipeline({
                layout: pipelineLayout,
                compute: { module: shaderModule, entryPoint: "update_h" }
            });
            
            const updateEPipeline = device.createComputePipeline({
                layout: pipelineLayout,
                compute: { module: shaderModule, entryPoint: "update_e" }
            });
            
             const updateSourcePipeline = device.createComputePipeline({
                layout: pipelineLayout,
                compute: { module: shaderModule, entryPoint: "update_source" }
            });

            const bindGroup = device.createBindGroup({
                layout: bindGroupLayout,
                entries: [
                    { binding: 0, resource: { buffer: paramsBuf } },
                    { binding: 1, resource: { buffer: epsBuf } },
                    { binding: 2, resource: { buffer: hzBuf } },
                    { binding: 3, resource: { buffer: exBuf } },
                    { binding: 4, resource: { buffer: eyBuf } },
                    { binding: 5, resource: { buffer: sourceValBuf } },
                ]
            });
            
            // Visualization Pipeline (Render Hz as texture)
            // Simplified: read back Hz to CPU and draw to canvas (slow but verifying logic first)
            // Ideally: Use fragment shader to render storage buffer directly.
            
            status.textContent = "Running Simulation...";

            let t = 0;
            function step() {
                const commandEncoder = device.createCommandEncoder();
                
                // Update Source (Gaussian pulse)
                t++;
                const val = Math.exp(-Math.pow((t - 50)/10, 2)) * 1.0;
                device.queue.writeBuffer(sourceValBuf, 0, new Float32Array([val]));

                const pass = commandEncoder.beginComputePass();
                pass.setBindGroup(0, bindGroup);
                
                // Update H
                pass.setPipeline(updateHPipeline);
                pass.dispatchWorkgroups(Math.ceil(simParams.nx/16), Math.ceil(simParams.ny/16));
                
                // Source
                pass.setPipeline(updateSourcePipeline);
                pass.dispatchWorkgroups(1);

                // Update E
                pass.setPipeline(updateEPipeline);
                pass.dispatchWorkgroups(Math.ceil(simParams.nx/16), Math.ceil(simParams.ny/16));
                
                pass.end();
                
                // For visualization prototype: just run simulation, no render yet
                // To visualize, we need a render pipeline reading hzBuf
                
                device.queue.submit([commandEncoder.finish()]);
                
                requestAnimationFrame(step);
            }
            
            step();
        }
        
        init();
    </script>
</body>
</html>
