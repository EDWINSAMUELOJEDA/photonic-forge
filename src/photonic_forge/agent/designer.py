"""Design agent for automated photonic device exploration.

Provides intelligent design generation and optimization using
neural surrogate models for fast evaluation.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import TYPE_CHECKING, Callable

import numpy as np

if TYPE_CHECKING:
    from photonic_forge.neural_models.surrogate import SurrogateModel
    from photonic_forge.optimize import OptimizationResult


@dataclass
class DesignCandidate:
    """A candidate design generated by the agent.

    Attributes:
        parameters: Design parameters.
        predicted_metrics: Metrics predicted by surrogate.
        score: Overall fitness score.
        generation: Which generation this came from.
    """
    parameters: np.ndarray
    predicted_metrics: dict[str, float] = field(default_factory=dict)
    score: float = 0.0
    generation: int = 0


@dataclass
class AgentConfig:
    """Configuration for design agent.

    Attributes:
        population_size: Number of candidates per generation.
        max_generations: Maximum exploration generations.
        elite_fraction: Fraction of top designs to keep.
        mutation_rate: Probability of mutation.
        exploration_factor: Random exploration vs exploitation.
    """
    population_size: int = 50
    max_generations: int = 20
    elite_fraction: float = 0.1
    mutation_rate: float = 0.2
    exploration_factor: float = 0.3


class DesignAgent:
    """Agent for automated design exploration.

    Uses neural surrogate models for fast evaluation, enabling
    rapid exploration of the design space.
    """

    def __init__(
        self,
        bounds: tuple[np.ndarray, np.ndarray],
        surrogate: SurrogateModel | None = None,
        objective_func: Callable[[np.ndarray], float] | None = None,
        config: AgentConfig | None = None,
    ):
        """Initialize design agent.

        Args:
            bounds: (lower, upper) parameter bounds.
            surrogate: Trained surrogate model for fast evaluation.
            objective_func: Alternative objective if no surrogate.
            config: Agent configuration.
        """
        self.lower, self.upper = bounds
        self.n_params = len(self.lower)
        self.ranges = self.upper - self.lower

        self.surrogate = surrogate
        self.objective_func = objective_func
        self.config = config or AgentConfig()

        self.history: list[DesignCandidate] = []
        self.best_candidate: DesignCandidate | None = None

    def evaluate(self, parameters: np.ndarray) -> tuple[dict[str, float], float]:
        """Evaluate a design candidate.

        Args:
            parameters: Design parameters.

        Returns:
            (predicted_metrics, score)
        """
        if self.surrogate is not None:
            # Use surrogate for fast evaluation
            # This assumes parameters can be converted to permittivity
            # In practice, you'd parameterize -> geometry -> permittivity
            metrics = {"surrogate_prediction": float(np.mean(parameters))}
            score = -np.sum(parameters**2)  # Placeholder objective
        elif self.objective_func is not None:
            score = self.objective_func(parameters)
            metrics = {"objective": score}
        else:
            # Random scoring for testing
            metrics = {}
            score = -np.sum((parameters - 0.5)**2)

        return metrics, score

    def random_candidate(self, generation: int = 0) -> DesignCandidate:
        """Generate a random design candidate."""
        params = self.lower + np.random.rand(self.n_params) * self.ranges
        metrics, score = self.evaluate(params)

        return DesignCandidate(
            parameters=params,
            predicted_metrics=metrics,
            score=score,
            generation=generation,
        )

    def mutate(self, candidate: DesignCandidate, generation: int) -> DesignCandidate:
        """Create mutated version of a candidate."""
        params = candidate.parameters.copy()

        # Apply mutations
        mask = np.random.rand(self.n_params) < self.config.mutation_rate
        mutation = (np.random.randn(self.n_params) * 0.1) * self.ranges
        params[mask] += mutation[mask]

        # Clamp to bounds
        params = np.clip(params, self.lower, self.upper)

        metrics, score = self.evaluate(params)

        return DesignCandidate(
            parameters=params,
            predicted_metrics=metrics,
            score=score,
            generation=generation,
        )

    def crossover(
        self,
        parent1: DesignCandidate,
        parent2: DesignCandidate,
        generation: int,
    ) -> DesignCandidate:
        """Create child from two parents."""
        alpha = np.random.rand(self.n_params)
        params = alpha * parent1.parameters + (1 - alpha) * parent2.parameters
        params = np.clip(params, self.lower, self.upper)

        metrics, score = self.evaluate(params)

        return DesignCandidate(
            parameters=params,
            predicted_metrics=metrics,
            score=score,
            generation=generation,
        )

    def explore(self, verbose: bool = True) -> list[DesignCandidate]:
        """Run design exploration.

        Args:
            verbose: Print progress.

        Returns:
            List of all explored candidates.
        """
        cfg = self.config

        # Initialize population
        population = [
            self.random_candidate(generation=0)
            for _ in range(cfg.population_size)
        ]

        self.history.extend(population)

        for gen in range(cfg.max_generations):
            # Sort by score (maximize)
            population.sort(key=lambda c: c.score, reverse=True)

            # Track best
            if self.best_candidate is None or population[0].score > self.best_candidate.score:
                self.best_candidate = population[0]

            if verbose and gen % 5 == 0:
                print(f"Generation {gen}: best_score = {self.best_candidate.score:.6f}")

            # Select elites
            n_elite = max(1, int(cfg.population_size * cfg.elite_fraction))
            elites = population[:n_elite]

            # Generate new population
            new_population = list(elites)

            while len(new_population) < cfg.population_size:
                if np.random.rand() < cfg.exploration_factor:
                    # Random exploration
                    child = self.random_candidate(generation=gen + 1)
                else:
                    # Crossover + mutation
                    p1, p2 = np.random.choice(elites, 2, replace=True)
                    child = self.crossover(p1, p2, generation=gen + 1)
                    child = self.mutate(child, generation=gen + 1)

                new_population.append(child)

            population = new_population
            self.history.extend(new_population[n_elite:])

        if verbose:
            print(f"\nExploration complete. Best score: {self.best_candidate.score:.6f}")
            print(f"Total candidates explored: {len(self.history)}")

        return self.history

    def get_top_candidates(self, n: int = 10) -> list[DesignCandidate]:
        """Get top N candidates by score."""
        sorted_history = sorted(self.history, key=lambda c: c.score, reverse=True)
        return sorted_history[:n]


def run_agent_exploration(
    bounds: tuple[np.ndarray, np.ndarray],
    objective_func: Callable[[np.ndarray], float],
    config: AgentConfig | None = None,
    verbose: bool = True,
) -> tuple[DesignCandidate, list[DesignCandidate]]:
    """Convenience function to run agent exploration.

    Args:
        bounds: Parameter bounds.
        objective_func: Objective to maximize.
        config: Agent configuration.
        verbose: Print progress.

    Returns:
        (best_candidate, all_candidates)
    """
    agent = DesignAgent(
        bounds=bounds,
        objective_func=objective_func,
        config=config,
    )

    candidates = agent.explore(verbose=verbose)
    return agent.best_candidate, candidates


__all__ = [
    "DesignCandidate",
    "AgentConfig",
    "DesignAgent",
    "run_agent_exploration",
]
